# Cellular Automaton

[_Клеточный автомат_](https://en.wikipedia.org/wiki/Cellular_automaton) представляет из себя `D`-мерный массив, каждая ячейка которого может находиться в каждый момент времени (поколении) в одном из множества состояний.

При смене поколения состояния ячеек меняются в соответствии с некоторым фиксированным правилом, по которому выбирается новое состояние каждой ячейки на основе её предыдущего состояния и предыдущих состояний ячеейк в некоторой её окрестности.

Вы скорее всего слышали про самый известный пример клеточного автомата &mdash; [Conway's Game of Life](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life).

В этом задании требуется реализовать эмулятор клеточных автоматов произвольной размерности, использующий заданное количество потоков для распараллеливания вычислений.

## Интерфейс

```cpp
template <typename State, std::size_t D = 2>
class GridView;

template <typename State, typename Rule, std::size_t D = 2>
class CellularAutomaton {
public:
  CellularAutomaton(const std::array<std::size_t, D>& extents, std::size_t n_threads, Rule rule = {});

  CellularAutomaton(const CellularAutomaton&) = delete;
  CellularAutomaton& operator=(const CellularAutomaton&) = delete;

  GridView<State, D> grid() noexcept;
  GridView<const State, D> grid() const noexcept;

  void step();
};
```

### `CellularAutomaton`

Шаблон класса `CellularAutomaton` принимает три параметра:

- `State` &mdash; тип для состояния одной ячейки (по умолчанию автомат инициализируется дефолтно-сконструированными состояниями ячеек);
- `Rule` &mdash; тип функционального объекта, задающий правило перехода;
- `D` &mdash; размерность автомата.

В конструкторе он принимает размеры каждого измерения сетки, а также количество потоков, которое должно использоваться для вычисления состояний ячеек у нового поколения.

Смена поколения осуществляется вызовом блокирующего метода `step()`. Гарантируется, что все публичные методы автомата используются из одного потока.

### `Rule`

Сигнатура правила перехода зависит от размерности автомата: первым параметром `Rule` всегда принимает старую сетку (`GridView<const State, D>`), а следующими `D` параметрами &mdash; индексы изменяемой ячейки. На основе этих параметров возвращается новое состояние для заданной ячейки.

Сейчас для шаблонного параметра `Rule` не задаётся constraint, проверяющий, что его можно вызвать с ожидаемыми типами аргументов, но вам **нужно его добавить**.

### `GridView`

`GridView` используется для чтения и изменения состояний ячеек автомата. Он должен предоставлять интерфейс, схожий с урезанным `std::mdspan`, а именно:

- `view.extent(dim)` &mdash; получить размер указанного измерения сетки (индексация с `0` по `D - 1`);
- `view[x, y, z]` &mdash; обратиться к ячейке по координатам, переданными отдельными аргументами (пример для `D = 3`);
- `view[arr]` &mdash; обратиться к ячейке по координатам, переданными в виде `std::array<std::size_t, D>`.

