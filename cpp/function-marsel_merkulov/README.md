# Function

Класс [`Function`](https://en.cppreference.com/w/cpp/utility/functional/function) представляет собой полиморфную оболочку для функциональных объектов, а именно для тех, чей тип удовлетворяет [Callable](https://en.cppreference.com/w/cpp/named_req/Callable) и [CopyConstructible](https://en.cppreference.com/w/cpp/named_req/CopyConstructible).
Это может быть указатель на функцию, лямбда, класс с перегруженным `operator()` и т.д.
Хранимый функциональный объект в терминах стандарта принято называть `target`.

### Small-object optimization

Функциональные объекты часто не имеют состояния вообще, или имеют, но небольшое.
Поэтому возникает естественное желание легковесные объекты хранить непосредственно внутри `Function`, вместо указателя на динамическую память.

### Идея реализации

Разделим хранилище и логику на два поля:

- выровненный массив байт, где будет лежать либо сам функциональный объект (в случае small object), либо указатель на него;
- указатель на _дескриптор_ &mdash; набор вспомогательных функций для оперирования хранилищем (может быть выражен структурой с набором указателей на функции).

В зависимости от типа функционального объекта, будем хранить указатели на дескрипторы для SOO и для обычного объекта.

### Прочие требования

Дефолтный конструктор создаёт пустой (empty) `Function`, который не хранит в себе никакой функциональный объект, а при вызове `operator()` кидает `BadFunctionCall`.
Для него удобно сделать отдельный дескриптор.

В отличие от стандартной библиотеки, ваш `Function` должен гарантировать небросающие мувающие операции (конструктор и оператор присваивания).
К сожалению, в общем случае это невозможно при SOO, поэтому используйте эту оптимизацию только для тех `T`, у которых мув и сам не бросает.

Метод `F* target<F>()` должен возвращать указатель на текущий функциональный объект, если его динамический тип совпадает с `F`, и `nullptr` иначе.
Вопреки написанному на cppreference, вам для этого не нужен `typeid`.

Обратите внимание на обеспечение корректного выравнивания для всех объектов, а также на корректное использование указателей, полученных из `reinterpret_cast` (вспомните про правила алиасинга и семантику `std::launder`).

При реализации SOO у вас (и на любых других системах) не должно оказаться неиспользованного паддинга, за счёт которого можно было бы ослабить требования к типу функциональных объектов, для которых SOO применим, без увеличения размера `Function`.
