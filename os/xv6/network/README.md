# Задание 4. Реализация сетевого стека

> Дедлайн — 28 ноября

В этой лабораторной работе вы напишете драйвер сетевой карты (NIC) для xv6, а затем — приёмную часть стека протоколов Ethernet/IP/UDP.

Вы будете портировать драйвер E1000, который используется для обработки сетевого трафика. QEMU предоставляет эмулятор локальной сети и сетевой карты, совместимой с этим драйвером. Для xv6 и вашего драйвера этот эмулятор будет выглядеть как реальное оборудование, подключенное к локальной сети Ethernet (LAN). QEMU создаёт виртуальную сеть, в которой xv6 (_гостевая система_) имеет IP-адрес `10.0.2.15`, а ваш компьютер (_хост_) имеет IP-адрес `10.0.2.2`. Когда xv6 с помощью E1000 отправляет пакет на `10.0.2.2`, QEMU передаёт его хосту.

Все пакеты, проходящие через эмуляцию, записываются в файл `packets.pcap` в директории вашей лабораторной работы. Вы можете просмотреть содержимое файла, чтобы убедиться, что xv6 корректно передаёт и принимает пакеты, с помощью [Wireshark](https://www.wireshark.org/) или консольной утилиты `tcpdump`:

```
tcpdump -XXnr packets.pcap
```

В репозитории xv6 вы найдёте несколько файлов. Файл [`kernel/e1000.c`](kernel/e1000.c) содержит код инициализации E1000, а также пустые функции для передачи и приёма пакетов, которые вам нужно будет реализовать. Файл [`kernel/e1000_dev.h`](kernel/e1000_dev.h) содержит определения регистров и флагов, используемых E1000. Файлы [`kernel/net.c`](kernel/net.c) и [`kernel/net.h`](kernel/net.h) содержат простой сетевой стек, реализующий протоколы IP, UDP и ARP. Файл [`kernel/net.c`](kernel/net.c) включает полный код, позволяющий пользовательским процессам отправлять UDP-пакеты, однако в нём отсутствует большая часть кода для приёма пакетов и доставки их в пользовательское пространство. Файл [`kernel/pci.c`](kernel/pci.c) содержит код, который выполняет поиск сетевой карты, совместимой с драйвером E1000, на шине PCI при загрузке xv6.

> Возможно, в процессе вам пригодится [руководство разработчика драйвера E1000](https://pdos.csail.mit.edu/6.828/2025/readings/8254x_GBe_SDM.pdf)

## Часть 1. Сетевая карта (NIC)

Ваша первая задача — реализовать функции `e1000_transmit()` и `e1000_recv()` в файле [`kernel/e1000.c`](kernel/e1000.c). Они отвечают за передачу и приём пакетов. В этой части вам нужно пройти тесты `txone` и `rxone` из `nettest`.

Функция `e1000_init()`, находящаяся в файле [`e1000.c`](kernel/e1000.c), настраивает сетевую карту так, чтобы она читала пакеты для передачи и записывала принятые пакеты напрямую в оперативную память. Этот процесс называется DMA (_Direct Memory Access_).

Поскольку пакеты могут приходить быстрее, чем драйвер успевает их обрабатывать, функция `e1000_init()` выделяет для сетевой карты несколько буферов, в которые карта может записывать принятые пакеты. E1000 требует, чтобы эти буферы были описаны массивом дескрипторов в памяти. Каждый дескриптор содержит адрес в RAM, куда сетевая карта может записать полученный пакет. Структура `struct rx_desc` описывает формат такого дескриптора. Массив дескрипторов называется кольцом приёма (_receive ring_) или очередью приёма (_receive queue_). Это — кольцо в том смысле, что, когда карта или драйвер достигают конца массива, они возвращаются к его началу. Функция `e1000_init()` выделяет буферы для пакетов с помощью `kalloc()`, чтобы карта могла записывать в них данные через DMA. Также существует кольцо передачи (_transmit ring_), в которое драйвер помещает пакеты, предназначенные для отправки. `e1000_init()` настраивает оба кольца так, чтобы их размер соответствовал `RX_RING_SIZE` и `TX_RING_SIZE`.

Когда стек сетевых протоколов в [`net.c`](kernel/net.c) должен отправить пакет, он вызывает `e1000_transmit()`, передавая указатель на буфер, содержащий пакет для отправки. [`net.c`](kernel/net.c) выделяет этот буфер через `kalloc()`. Ваш код передачи должен поместить указатель на данные пакета в дескриптор в кольце передачи (TX). Структура `struct tx_desc` описывает формат таких дескрипторов. Нужно убедиться, что каждый буфер в конце будет освобождён с помощью `kfree()`, но только после того, как сетевая карта закончит передачу пакета. Контроллер сообщает об этом, устанавливая бит `E1000_TXD_STAT_DD` в соответствующем дескрипторе.

Когда сетевая карта принимает пакет по Ethernet, она при помощи DMA записывает его в память по адресу, указанному в поле `addr` следующего дескриптора в кольце приёма (RX). Если в данный момент прерывание приёма E1000 ещё не ожидается, карта сообщает контроллеру прерываний (PLIC) о необходимости вызвать прерывание, как только это будет возможно. Ваш код `e1000_recv()` должен просканировать кольцо приёма RX, обнаружить все новые пакеты и передать их в сетевой стек (в [`net.c`](kernel/net.c)), вызывая функцию `net_rx()`. Затем вам нужно выделить новый буфер и поместить его в соответствующий дескриптор, чтобы при следующем обращении к этому месту в кольце RX у E1000 был свежий буфер для приёма нового пакета.

Помимо чтения и записи колец дескрипторов в памяти, ваш драйвер должен взаимодействовать с E1000 через регистры управления, отображённые в память (memory-mapped control registers). Это необходимо для определения доступности новых пакетов и сообщения контроллеру сетевой карты о заполнении некоторых TX дескрипторов. Глобальная переменная `regs` содержит указатель на первый регистр управления `E1000`. Чтобы обратиться к другим регистрам, ваш драйвер может использовать индексацию `regs` как массива. Особенно нужно использовать регистры с индексами `E1000_RDT` и `E1000_TDT`.

Чтобы протестировать функцию `e1000_transmit()`, отправляющую одиночный пакет, в одном окне запустите `python3 nettest.py txone`, в другом выполните `make qemu`, а затем в xv6 запустите `nettest txone`. Если всё прошло успешно, `nettest.py` выведет `txone: OK`. Это означает, что эмулятор E1000 в QEMU увидел пакет в DMA-кольце и успешно переслал его из QEMU.

Если передача работает корректно, команда `tcpdump -XXnr packets.pcap` должна вывести примерно следующее:

```
reading from file packets.pcap, link-type EN10MB (Ethernet)
21:27:31.688123 IP 10.0.2.15.2000 > 10.0.2.2.25603: UDP, length 5
        0x0000:  5255 0a00 0202 5254 0012 3456 0800 4500  RU....RT..4V..E.
        0x0010:  0021 0000 0000 6411 3ebc 0a00 020f 0a00  .!....d.>.......
        0x0020:  0202 07d0 6403 000d 0000 7478 6f6e 65    ....d.....txone
```

Чтобы протестировать `e1000_recv()`, принимающую 2 пакета (сначала ARP-запрос, затем IP/UDP-пакет), в одном окне запустите `make qemu`, в другом `python3 nettest.py rxone`. Сценарий `nettest.py rxone` отправит UDP-пакет через QEMU в xv6.

На самом деле, при работе этого теста вы увидите сразу несколько пакетов. Дело в том, что просто взять и отправить UDP-пакет, зная только IP-адрес, нельзя — в Ethernet-фрейме такого пакета обязательным полем является MAC-адрес сетевой карты получателя: именно по нему происходит доставка. Чтобы узнать этот MAC-адрес, сначала хост отправит _ARP-запрос_ — запрос вида «кому принадлежит IP 10.0.2.15». xv6 должен ответить ARP-ответом, только после этого хост узнает нужный адрес и сможет направить UDP-пакет.

Если `e1000_recv()` работает корректно и передаёт эти пакеты в `net_rx()`, в [`net.c`](kernel/net.c) должно появиться:

```
arp_rx: received an ARP packet
ip_rx: received an IP packet
```

[`net.c`](kernel/net.c) уже содержит код для обнаружения ARP-запроса от QEMU и вызова `e1000_transmit()` для отправки ARP-ответа. Этот тест требует, чтобы и `e1000_transmit()` и `e1000_recv()` работали корректно. Также, если всё прошло успешно, команда `tcpdump -XXnr packets.pcap` должна вывести что-то подобное:

```
reading from file packets.pcap, link-type EN10MB (Ethernet)
21:29:16.893600 ARP, Request who-has 10.0.2.15 tell 10.0.2.2, length 28
        0x0000:  ffff ffff ffff 5255 0a00 0202 0806 0001  ......RU........
        0x0010:  0800 0604 0001 5255 0a00 0202 0a00 0202  ......RU........
        0x0020:  0000 0000 0000 0a00 020f                 ..........
21:29:16.894543 ARP, Reply 10.0.2.15 is-at 52:54:00:12:34:56, length 28
        0x0000:  5255 0a00 0202 5254 0012 3456 0806 0001  RU....RT..4V....
        0x0010:  0800 0604 0002 5254 0012 3456 0a00 020f  ......RT..4V....
        0x0020:  5255 0a00 0202 0a00 0202                 RU........
21:29:16.902656 IP 10.0.2.2.61350 > 10.0.2.15.2000: UDP, length 3
        0x0000:  5254 0012 3456 5255 0a00 0202 0800 4500  RT..4VRU......E.
        0x0010:  001f 0000 0000 4011 62be 0a00 0202 0a00  ......@.b.......
        0x0020:  020f efa6 07d0 000b fdd6 7879 7a         ..........xyz
```

Ваш вывод может немного отличаться, но в нём должны присутствовать строки `ARP, Request`, `ARP, Reply`, `UDP` и `…xyz`.

Запустите тесты `rxone` и `txone` и убедитесь, что они проходят.

### Подсказки

Начните с добавления отладочных сообщений в функции `e1000_transmit()` и `e1000_recv()`, а затем запустите (в xv6) команду `nettest txone`. Вы должны увидеть, что `nettest txone` действительно приводит к обращению к функции `e1000_transmit()`.

Подсказки для реализации `e1000_transmit`:

- Сначала узнайте индекс дескриптора TX кольца, в который E1000 ожидает следующий пакет. Для этого прочитайте значение управляющего регистра `E1000_TDT`.
- Затем проверьте, не переполняется ли кольцо. Если в дескрипторе с индексом `E1000_TDT` не установлен бит `E1000_TXD_STAT_DD`, значит, контроллер ещё не завершил предыдущую передачу и вернёт ошибку.
- Освободите предыдущий буфер, который был передан из этого дескриптора (если такой был), вызвав `kfree()`.
- Затем заполните дескриптор. Установите необходимые флаги `cmd` и сохраните указатель на буфер, чтобы позднее освободить его.
- Наконец, обновите позицию кольца, увеличив `E1000_TDT` на 1 по модулю `TX_RING_SIZE`.
- Если `e1000_transmit()` успешно добавила пакет в кольцо, функция должна вернуть 0. Если произошла ошибка (например, нет свободных дескрипторов), верните -1, чтобы вызывающая сторона знала, что нужно освободить буфер.

Подсказки для реализации `e1000_recv`:

- Сначала узнайте индекс в кольце приёма, по которому ожидается следующий принятый пакет (если он есть). Для этого получите значение `E1000_RDT` и прибавьте 1 по модулю `RX_RING_SIZE`.
- Затем проверьте, доступен ли новый пакет. Если в статусе дескриптора не установлен бит `E1000_RXD_STAT_DD`, значит, новых пакетов нет — можно остановиться.
- Передайте буфер с пакетом в сетевой стек, вызвав `net_rx()`.
- Затем выделите новый буфер с помощью `kalloc()`, чтобы заменить тот, что вы только что передали в `net_rx()`. После этого обнулите статусные биты дескриптора.
- Наконец, обновите регистр `E1000_RDT`, установив его в индекс последнего обработанного дескриптора кольца.
- Функция `e1000_init()` уже инициализирует кольцо RX и выделяет буферы. Изучите её реализацию — оттуда можно взять часть кода.
- В какой-то момент общее количество полученных пакетов превысит размер кольца (например, 16). Убедитесь, что ваш код корректно обрабатывает этот момент.
- Контроллер E1000 может доставлять несколько пакетов за одно прерывание, поэтому ваша функция `e1000_recv()` должна уметь обрабатывать сразу несколько пакетов за один вызов.

Не забудьте использовать блокировки, поскольку xv6 может обращаться к E1000 из нескольких процессов или из потока ядра, когда происходит прерывание.

## Часть 2: Приём UDP-пакетов

[UDP](https://en.wikipedia.org/wiki/User_Datagram_Protocol) (User Datagram Protocol — протокол пользовательских датаграмм) позволяет пользовательским процессам на разных хостах Интернета обмениваться отдельными пакетами (датаграммами). UDP работает поверх IP. Пользовательский процесс указывает, какому хосту он хочет отправить пакет, задавая 32-битный IP-адрес. Каждый UDP-пакет содержит номер порта источника и номер порта назначения. Процессы могут запрашивать получение пакетов, адресованных конкретным портам, и указывать порт назначения при отправке. Таким образом, два процесса на разных хостах могут обмениваться сообщениями по UDP, если они знают IP-адреса друг друга и номера портов, на которых слушают соединения. Например, Google управляет DNS-сервером на хосте с IP-адресом 8.8.8.8, который слушает UDP-порт 53.

В этом задании вы добавите код в [`kernel/net.c`](kernel/net.c), чтобы принимать UDP-пакеты, ставить их в очередь и позволять пользовательским процессам их считывать. Файл [`net.c`](kernel/net.c) уже содержит код, позволяющий отправлять UDP-пакеты пользовательским процессам (кроме `e1000_transmit()`, который нужно реализовать вам).

Ваша задача — реализовать функции `ip_rx()`, `sys_recv()`, и `sys_bind()` в [`kernel/net.c`](kernel/net.c).

API системных вызовов xv6 для работы с UDP:

- `send(short sport, int dst, short dport, char *buf, int len)`: Отправляет UDP-пакет хосту с IP адресом `dst`, процессу, слушающему порт `dport`. Порт источника (`sport`) указывается отправителем, он будет передан получателю, чтобы тот мог ответить. Содержимое пакета (`payload`) — `len` байт из буфера `buf`. Возвращает 0 при успехе и -1 при ошибке.
- `recv(short dport, int *src, short *sport, char *buf, int maxlen)`: Возвращает содержимое UDP-пакета, адресованного порту `dport`. Если один или несколько пакетов пришли до вызова `recv()`, возвращает самый ранний. Если пакетов нет, `recv()` ждёт до тех пор, пока не придёт пакет для `dport`. Пакеты для одного порта обрабатываются в порядке поступления. `recv()` записывает 32-битный IP-адрес источника в `*src`, копирует 16-битный UDP-порт источника в `*sport`, копирует до `maxlen` байт информации пакета в `buf` и удаляет пакет из очереди (даже если он не вычитан целиком). Возвращает количество скопированных байт, либо -1 при ошибке.
- `bind(short port)`: Процесс должен вызвать `bind(port)` до вызова `recv(port, ...)`. Если UDP-пакет приходит на порт, который не был связан через `bind()`, [`net.c`](kernel/net.c) должен отбросить этот пакет. Этот вызов нужен, чтобы инициализировать структуры в [`net.c`](kernel/net.c), которые будут хранить входящие пакеты до вызова `recv()`.
- `unbind(short port)`: Реализовывать этот вызов не требуется, так как тесты его не используют. Однако вы можете добавить его для симметрии с `bind()`.

Все адреса и номера портов, передаваемые в эти системные вызовы и возвращаемые ими, должны быть в порядке байтов хоста. Пользовательская программа [`user/nettest.c`](user/nettest.c) использует этот API.  Вам нужно добавить реализации системных вызовов в ядре (кроме `send()`).

Чтобы `recv()` работал, нужно добавить код в функцию `ip_rx()`, которую вызывает `net_rx()` для каждого полученного IP-пакета. `ip_rx()` должна определить, является ли входящий пакет UDP, и был ли его порт назначения ранее зарегистрирован вызовом `bind()`. Если оба условия выполняются, пакет сохраняется там, где `recv()` может позже его найти.

Для любого порта не должно храниться более 16 пакетов. Если 16 пакетов уже ожидают вызова `recv()`, новый входящий пакет для этого порта нужно отбросить. Это ограничение нужно, чтобы слишком быстрый отправитель или злоумышленник не смог бы переполнить память операционной системы. При этом, если пакеты для одного порта отбрасываются из-за переполнения (уже 16 в очереди), это не должно влиять на обработку пакетов, приходящих для других портов.

Буферы пакетов, которые анализирует `ip_rx()`, содержат 14-байтовый Ethernet-заголовок, за ним — 20-байтовый IP-заголовок, затем — 8-байтовый UDP-заголовок, и, наконец, информацию (payload) UDP. Структуры C для всех этих заголовков уже определены в [`kernel/net.h`](kernel/net.h).

Реальные реализации IP/UDP гораздо сложнее: они обрабатывают дополнительные опции протоколов и проверяют целостность данных. Вам нужно реализовать только минимально необходимое для прохождения всех тестов из `nettest`. Ваш код должен учитывать `ip_p` и `ip_src` в IP-заголовке и к `dport`, `sport` и `ulen` в UDP-заголовке.

Обратите внимание на __порядок байтов__. В Ethernet, IP и UDP-поля заголовка, содержащие многобайтовые числа, хранят старший байт первым (Big-Endian). Процессор RISC-V, напротив, хранит многобайтовые числа в обратном порядке — младший байт первым (Little-Endian). Это значит, что при извлечении многобайтовых чисел из сетевых пакетов нужно переставлять байты. Это относится к типам short (2 байта) и int (4 байта). Для преобразования используйте функции `ntohs()` (network to host short) для 2 байтов и `ntohl()` для 4 байтов. Посмотрите пример в `net_rx()`, где эти функции применяются для поля типа Ethernet (2 байта).

Если в вашем коде для E1000 есть проблемы, они могут проявиться только во время ping-тестов. Например, эти тесты отправляют и принимают достаточно пакетов, чтобы индексы дескрипторов кольца успели «замкнуться» и начать перезаписываться.

### Тестирование решения
Задание считается выполненным, когда команда `./grade` покажет, что все тесты успешно пройдены.

Вы можете запустить те же тесты, что выполняет `./grade`, выполнив в одном окне `python3 nettest.py grade`, а в другом (внутри xv6) `nettest grade`. Если всё работает, `nettest.py` выведет в поток стандартного вывода:

```
python3 ./nettest.py grade
tx: listening for a UDP packet
txone: OK
rx2: sending UDP packages
start listen
```

А в окне xv6 будет:

```
nettest grade
txone: sending one packet
rx2: OK
ping0: starting
ping0: OK
ping1: starting
ping1: OK
FAILED ping2: starting
ping2: OK
ping3: starting
ping3: OK
dns: starting
dns arecord for nerc.itmo.ru. is 77.234.215.132
dns: OK
free: OK
Tests OK
```

Кроме того, вы можете запустить отдельные тесты, передав соответствующий режим в качестве аргумента `nettest` внутри xv6 и `nettest.py` снаружи.
- `txone` — отправляет один UDP-пакет из xv6 на порт хостовой ОС.
- `rx` (или `rxone`) — отправляет один или несколько UDP-пакетов из хостовой ОС в xv6.
- `rx2` — отправляет по два UDP-пакета из хостовой ОС на два разных порта xv6.
- `ping0`, `ping1`, `ping2` — отправляют серию пакетов из xv6 на хостовую ОС и ожидают получить обратно пакет с тем же содержимым.
- `ping3` — отправляет много пакетов на разные порты и проверяет, что ответы, адресованные прослушиваемому порту корректно принимаются, даже при переполнении очередей других портов.
- `dns` — отправляет dns-запрос на сервер `8.8.8.8` и проверяет правильность разрешения доменного имени `nerc.itmo.ru`.

### Подсказки

- Создайте структуру, которая будет хранить сведения о привязанных портах и очередях пакетов.
- Посмотрите на функции `sleep(void *chan, struct spinlock *lk)` и `wakeup(void *chan)` в файле [`kernel/proc.c`](kernel/proc.c) — они помогут реализовать логику ожидания для `recv()`.
- Адреса назначения, в которые `sys_recv()` копирует данные пакетов, являются виртуальными адресами; значит, придётся копировать данные из ядра в память текущего пользовательского процесса.
- Не забудьте освобождать память от пакетов, которые уже были скопированы или отброшены.
- В базовых тестах используются порты с номером не больше 2048, вы можете полагаться на это при выполнении этого пункта.

## Часть 3*. unbind (+1 балл)

В основном задании вы реализовали системный вызов `bind`, который позволяет процессу слушать входящие UDP-пакеты, адресованные указанному порту. В текущей реализации после завершения процесса ресурсы, выделенные для прослушивания порта, не освобождаются. Это может привести к утечке памяти и блокировке порта, поскольку тот останется занятым после завершения процесса.

Реализуйте системный вызов `unbind(int port)`, который будет освобождать ресурсы, связанные с ранее вызванным `bind(port)`.
После вызова `unbind(port)` ядро должно удалить все очереди пакетов, созданные при `bind()`, а все новые UDP-пакеты, адресованные этому порту, должны игнорироваться.

- Если порт не был ранее привязан (`bind` не вызывался), `unbind` должен возвращать `-1`.
- Если порт успешно отвязан, необходимо вернуть `0`.
- После `unbind` повторный вызов `bind` должен позволять снова принимать новые UDP-пакеты.

Пункт считается выполненным, когда команда `./grade-bonus-unbind` покажет, что все тесты успешно пройдены.

## Часть 4*. Эффективное хранение буферов UDP-портов (+2 балла)

В базовой реализации сетевого стека буфер каждого UDP-порта мог храниться в статическом массиве `ports[]`, с фиксированным размером.

Такой подход прост, но плохо масштабируется: он расходует фиксированный объём оперативной памяти, независимо от количества реально используемых портов.

В этом бонусном задании требуется реализовать динамическое, эффективное хранение буферов UDP-портов.

Требования:

- Реализация должна поддерживать произвольное количество активных портов (до 65535), без существенного роста потребления памяти.
- Память необходимая для хранения очередного порта должна выделяться лениво, то есть только после вызова `bind` для соответствующего порта.
- Очередь буферов порта по сути состоит из 16 указателей на соответствующие буферы и их длины, что значительно меньше чем размер одной страницы виртуальной памяти (4 КБ). Поэтому вам необходимо хранить порты эффективнее, чем один порт на страницу.

Пункт считается выполненным, когда команда `./grade-bonus-allports` покажет, что все тесты успешно пройдены.

## Часть 5*. Реализация сетевого сниффера (+4 балла)

В этом бонусном задании вы реализуете простейший сетевой сниффер — подсистему ядра, позволяющую наблюдать проходящие через сетевой стек пакеты. В результате у вас получится утилита, работающая аналогично `tcpdump` в Linux.

Задача состоит из трёх последовательных частей: организация хранения пакетов в ядре, предоставление интерфейса чтения из пользовательского пространства и реализация пользовательской утилиты для отображения информации о пакетах.

### 5.1. Хранение пакетов в ядре

Реализуйте внутри ядра структуру сниффера, которая сохраняет последние 16 пакетов, поступивших из сети.
Каждый пакет должен сохраняться вместе с отметкой времени (timestamp) и длиной данных.
Для этого в [`kernel/net.h`](kernel/net.h) уже определена структура `struct sniffer_record`.

Сниффер должен работать как кольцевой буфер фиксированного размера: при переполнении старые записи должны вытесняться новыми.
Обеспечьте корректную работу при одновременном доступе из разных контекстов — реализация должна быть потокобезопасной.

Каждый раз, когда драйвер сети получает пакет в `net_rx`, информация о нём должна записываться в буфер сниффера.

Совет: реализацию структуры для сохранения пакетов сниффера удобно можно вынести в отдельную единицу трансляции, например, `netsniffer.c`.

### 5.2. Интерфейс чтения из пользовательского пространства

Определите символьное устройство `DEV_SNIFFER` с отдельным *major*-номером `2`.
Чтение из этого устройства должно возвращать данные о пакетах, сохранённых сниффером.
При каждом чтении пользователь получает одну структуру `sniffer_record`, содержащую метку времени, длину и данные пакета. Если буфер пуст, чтение должно вернуть ноль байт.

После чтения запись из буфера сниффера должна удаляться, чтобы новые пакеты могли занимать место освободившихся.

Интерфейс работы должен быть аналогичен другим устройствам (например, `console`): настройте запись соответствующей функции чтения в таблице устройств `devsw`. При реализации вы можете опираться на то, как реализовано устройство `CONSOLE` (стандартный поток ввода и вывода).

Также необходимо добавить новое устройство `DEV_SNIFFER` в файловую систему xv6 как файл типа `FD_DEVICE`, чтобы к нему можно было обращаться с помощью стандартных системных вызовов `open`, `read` и `close`.

### 5.3. Пользовательская утилита
Создайте пользовательское приложение `netsniffer`, которое открывает файловый дескриптор для взаимодействия с `DEV_SNIFFER` и в бесконечном цикле читает из него данные о пакетах, поступающих в систему.

Программа должна выводить информацию о каждом перехваченном пакете в удобочитаемом формате.

```text
<ticks> ARP, length <полная длина пакета>
<ticks> IP <src_ip>:<src_port> > <dst_ip>:<dst_port> UDP, length <длина полезных данных>: <первые 16 байт полезной нагрузки в hex>
```

Здесь:
- `<ticks>` — значение системного таймера (аналог времени получения пакета);
- `<src_ip>` и `<dst_ip>` — адреса отправителя и получателя;
- `<src_port>` и `<dst_port>` — соответствующие UDP-порты.

Пример вывода:
```text
58 ARP, length 60
58 IP 10.0.2.2:37332 > 10.0.2.15:2000 UDP, length 6: 68 65 6C 6C 6F 0A
1911 IP 10.0.2.2:37332 > 10.0.2.15:2001 UDP, length 12: 61 62 6F 62 61 20 61 62 6F 62 61 0A
```

Вы можете протестировать свой сниффер с помощью `nettest.py rxone` или воспользовавшись консольной утилитой [`netcat`](https://man7.org/linux/man-pages/man1/ncat.1.html).

Пункт считается выполненным, когда команда `./grade-bonus-sniffer` покажет, что все тесты успешно пройдены.

> Помните, что все бонусные задания сдаются только вместе с основным.
