# Задание 6. Сетевая файловая система (FUSE)

В этом задании мы с Вами реализуем упрощённый аналог [NFS](https://en.wikipedia.org/wiki/Network_File_System): все файлы будут храниться на удалённом сервере, однако пользователь сможет пользоваться ими точно так же, как и файлами на собственном жёстком диске.

В отличие от классических файловых систем, работающих в пространстве ядра (kernel space), мы будем использовать технологию [FUSE](https://en.wikipedia.org/wiki/Filesystem_in_Userspace) (Filesystem in Userspace). Это позволяет разрабатывать файловые системы как обычные пользовательские приложения, что существенно упрощает их эксплуатацию, разработку и надёжность (падение ФС не влечёт падение ОС).

> Выполните задание в ветке `networkfs`.

## Системные требования

Тесты запускаются на ОС с ядром Linux. Ваше решение должно работать в тестовом окружении. Для macOS существует [macFUSE](https://macfuse.github.io/), вы можете поддержать работу с ним в вашем решении. Для Windows хороших проверенных аналогов нам не известно, поэтому задание рекомендуется выполнять в WSL2 или в виртуальной машине.

Для выполнения задания вам понадобятся компилятор C++, поддерживающий стандарт C++20, система сборки Meson и библиотека `libfuse3`.

Установить необходимые зависимости на Ubuntu можно командой:

```bash
sudo apt install build-essential meson pkg-config libfuse3-dev libgtest-dev
```

## Сервер файловой системы

Все файлы и структура директорий хранятся на удалённом сервере. Сервер поддерживает HTTP API, документация к которому доступна [по ссылке](https://nerc.itmo.ru/teaching/os/networkfs/).

Для получения токенов и тестирования вы можете воспользоваться консольной утилитой [curl](https://curl.se).

Сервер поддерживает два типа ответов:
* Бинарные данные: набор байт, который можно скастить в структуру, указанную в описании ответа. Учтите, что первое поле ответа (первые 8 байт) — код ошибки.
* [JSON-объект](https://www.json.org/json-en.html): человекочитаемый ответ. Для его получения необходимо передавать GET-параметр `json`.

> [!IMPORTANT]
>
> Для начала работы вам необходимо завести собственный бакет — пространство для хранения файлов, и получить токен для доступа к нему. Это делается следующим запросом:
> 
> ```sh
> $ curl https://nerc.itmo.ru/teaching/os/networkfs/v1/token/issue?json
> {"status":"SUCCESS","response":"8c6a65c8-5ca6-49d7-a33d-daec00267011"}
> ```

Строка `8c6a65c8-5ca6-49d7-a33d-daec00267011` и является токеном, который необходимо передавать во все последующие запросы. Количество токенов и размер файловой системы не ограничены, однако, мы будем вынуждены ограничить пользователей в случае злоупотребления данной возможностью.

Мы реализовали для вас HTTP-клиент в виде функции `networkfs_http_call` ([`src/http.h`](src/http.h)):

```cpp
int64_t networkfs_http_call(
    const char *token,
    const char *method,
    char *response_buffer,
    size_t buffer_size,
    std::span<const std::pair<std::string, std::string>> args
);
```

* `token` — ваш токен.
* `method` — название метода без неймспейса `fs` (`list`, `create`, …).
* `response_buffer` — буфер для сохранения ответа от сервера.
* `buffer_size` — размер буфера.
* `args` — список аргументов запроса в виде пар "ключ-значение".

Функция возвращает 0 (`NFS_SUCCESS`), если запрос завершён успешно; положительное число — код ошибки из документации API, если сервер вернул ошибку; отрицательное число — системная ошибка (например, сбой сети).

## Знакомство с проектом

Мы подготовили для вас шаблон проекта. Основные файлы:
* `src/main.cpp` — точка входа, инициализация FUSE сессии.
* `src/inode.cpp` — реализация операций файловой системы.
* `src/http.cpp` / `src/http.h` — реализация HTTP-клиента.

Также вам понадобится скачать Git-репозитории с зависимостями. Для этого выполните команду `git submodule update --init --recursive`.

Сборка проекта осуществляется с помощью Meson:

```sh
$ meson setup build
$ meson compile -C build
```

После успешной сборки в директории `build` появится исполняемый файл `networkfs`.

Для запуска файловой системы необходимо передать токен через переменную окружения `NETWORKFS_TOKEN` и указать точку монтирования:

```sh
$ mkdir mnt
$ NETWORKFS_TOKEN=your-token ./build/networkfs mnt
```

Чтобы размонтировать файловую систему, используйте команду:

```sh
$ fusermount3 -u mnt
```

## Часть 1. Инициализация

FUSE работает через набор коллбеков, которые вызываются при обращении к файловой системе. Эти функции описываются в структуре [`fuse_lowlevel_ops`](https://libfuse.github.io/doxygen/structfuse__lowlevel__ops.html).

В файле `src/inode.cpp` найдите структуру `networkfs_oper`. Сейчас она содержит заглушки.

Первая функция, с которой мы познакомимся — `init`. Она вызывается при инициализации файловой системы.

```cpp
void networkfs_init(void *userdata, struct fuse_conn_info *conn) {
    // ...
}
```

В этой функции вы можете выполнить необходимую инициализацию. Например, настроить параметры соединения с драйвером FUSE в ядре.

> [!NOTE]
> В FUSE Low-level API многие функции принимают аргумент `fuse_req_t req`. Это идентификатор запроса, на который вы **должны** ответить одной из функций `fuse_reply_*`. Если вы не ответите на запрос, процесс, обратившийся к файловой системе, зависнет.
>
> Список возможных ответов на запрос перечислен в документации к соответствующему коллбеку.

## Часть 2. Вывод файлов и директорий

Чтобы увидеть файлы в директории, нам нужно реализовать две операции: `lookup` и `readdir`.

### Lookup

Функция `lookup` ищет файл по имени в родительской директории и возвращает информацию о нём (inode, права доступа и т.д.). В данной функции нужно:

1. Сделать запрос к серверу.
2. Если файл найден, заполнить структуру `fuse_entry_param`.
3. Ответить `fuse_reply_entry(req, &e)`.
4. Если не найден — `fuse_reply_err(req, ENOENT)`.

Структура `fuse_entry_param` содержит:
* `ino` — номер inode (получаем от сервера).
* `attr` — атрибуты файла (`struct stat`). Очень важно правильно заполнить `st_mode` (права доступа и тип файла: `S_IFDIR` или `S_IFREG`) и `st_size`.
* `attr_timeout`, `entry_timeout` — время кеширования атрибутов ядром, можно выставить 0 или 1.0.

### Readdir

Функция `readdir` (в нашей реализации она может называться `networkfs_iterate`) отвечает за получение списка файлов в директории. В данной функции нужно:

1. Сделать запрос к серверу.
2. Заполнить буфер с помощью `fuse_add_direntry`.
3. Отправить буфер через `fuse_reply_buf`.

Функция [`fuse_add_direntry`](https://libfuse.github.io/doxygen/fuse__lowlevel_8h.html) помогает правильно упаковать информацию о файле в буфер. Обратите внимание, что `readdir` может вызываться несколько раз с разным `off` (смещением), если список файлов большой.

> [!IMPORTANT]
> Номер корневой директории в FUSE захардкожен: `#define FUSE_ROOT_ID 1`. На сервере networkfs корневая директория имеет `ino = 1000` (функция `ino_to_string` в `util.h` уже учитывает это).

После реализации этих функций вы должны увидеть список файлов:

```sh
$ ls -l mnt
```

## Часть 3. Создание и удаление файлов

Реализуйте функции `create` и `unlink`.

* `create` вызывается, когда пользователь создает новый файл. Вам нужно вызвать метод `create` на сервере, получить новый inode и вернуть его через `fuse_reply_create`.
* `unlink` удаляет файл. Вызовите метод `unlink` на сервере и ответьте `fuse_reply_err(req, 0)` в случае успеха.

Обратите внимание, что `fuse_reply_create` принимает не только `fuse_entry_param`, но и `fuse_file_info`. Это позволяет привязывать произвольные данные к структуре открытого файла с целью их переиспользования (см. Часть 5 про чтение и запись). Пока можно оставить `fi->fh` без изменений.

## Часть 4. Создание и удаление директорий

Аналогично файлам, реализуйте `mkdir` и `rmdir`.

* `mkdir` использует метод `create` API с типом `directory`.
* `rmdir` использует метод `rmdir` API.

## Часть 5. Чтение и запись в файлы

Для поддержки чтения и записи нужно реализовать: `open`, `read`, `write`, `flush`, `release`, `setattr`.

### Open и Release

При открытии файла (`open`) будет удобно выделить буфер в памяти, который будет хранить содержимое файла, так как сервер позволяет скачать файл только целиком. Указатель на этот буфер можно сохранить в поле `fi->fh` (file handle) структуры `fuse_file_info`. Функция `release` будет вызываться при закрытии файла.

```cpp
struct file_buffer {
    char *data;
    size_t size;
};

void networkfs_open(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi) {
    // Скачать контент файла с сервера (метод read)
    // Выделить file_buffer
    // Установить file_buffer в fi->fh
    // fuse_reply_open(req, fi);
}

void networkfs_release(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi) {
    // Освободить file_buffer
    // fuse_reply_err(req, 0);
}
```

Теперь все коллбеки, принимающие file handle, могут переиспользовать общие данные, связанные с открытым файлом.

> [!NOTE]
> Не забудьте установить file handle в функции `create` из части 3.

### Read и Write

Операции `read` и `write` теперь могут работать с локальным буфером в памяти, доступным через `fi->fh`.

* `read`: копирует данные из буфера в ответ (`fuse_reply_buf`).
* `write`: обновляет данные в буфере. Обратите внимание на изменение размера файла.

### Синхронизация (Flush / Fsync)

Изменения в буфере локальны. Чтобы отправить их на сервер, используйте `flush` (вызывается при закрытии файла) или `fsync`. Вам нужно отправить содержимое буфера методом `write` API.

### Setattr

Чтобы изменять размер файла (например, при `truncate`), нужно реализовать `setattr`. Если приходит запрос на изменение размера (`to_set & FUSE_SET_ATTR_SIZE`), обновите размер буфера и, при необходимости, синхронизируйте с сервером.

## Часть 6. Жёсткие ссылки

Реализуйте `link`. Сервер поддерживает метод `link`, который создает жесткую ссылку. В FUSE соответствующая операция — `link`.

Вам также понадобится корректно обрабатывать `nlink` (количество ссылок) в `getattr` и `lookup`.

Теперь вы можете запустить тесты:

```sh
$ meson test -C build --verbose
```

Вы также можете запускать по одному набору тестов или даже конкретные тесты командой вида

```sh
build/networkfs-test --gtest_filter=LinkTest.*
```

Убедитесь перед этим, что проект собран и у вас есть свежий бинарный файл `networkfs_test`.

Задание проверяется четырьмя наборами тестов:
- `BaseTest` — базовые тесты, проверяющие создание и удаление директорий и файлов
- `LinkTest` — тесты на жёсткие ссылки
- `EncodingTest` — тесты на файлы со специальными и не-ASCII-символами
- `FileTest` — тесты на чтение и запись файлов

Обратите внимание, что тесты используют директорию `/mnt/networkfs-test` для монтирования ФС. Убедитесь, что эта директория существует и ваш пользователь ей владеет.

## Часть 7*. Неблокируюший однопоточный event-loop (+4 балла)

Как нетрудно заметить, текущая архитектура драйвера довольна примитивна и неэффективна: на каждый запрос устанавливается новое соединение с сервером, а операции чтения и записи — блокирующие.

В данной части требуется реализовать неблокирующий однопоточный event-loop при помощи `epoll`. Эта функциональность Linux позволяет ожидать события на нескольких файловых дескрипторах одновременно. Ключевой возможностью является ожидание _возможности_ чтения/записи в дескрптор: в обычной ситуации вызовы `read()`/`write()` блокируются до тех пор, пока не будут доступны данные. Корректное использование `epoll` гарантирует отсутствие блокировоки на этих сисколлах.

Для реализации выполните следующее:

* Переиспользуйте один и тот же HTTP-клиент при помощи HTTP Keep-Alive. Это позволяет сохранять TCP-соединение между клиентом и сервером.
* Пометьте файловые дескрипторы HTTP- и FUSE-клиента как `O_NONBLOCK` (дескриптор FUSE-дескриптора получется из `fuse_session_fd()`).
* Вместо `fuse_session_loop()` используйте пару `fuse_session_receive_buf()` и `fuse_session_process_buf()`.
* Добавьте дескрипторы в `epoll()`, ожидайте новые события вызывом `epoll_wait()` и выполняйте доступные операции.
